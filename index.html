<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LA Tours Overview</title>
    <link href="https://fonts.googleapis.com/css2?family=Gothic+A1:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            font-family: 'Gothic A1', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            color: #100c08;
            background: #fafafa;
        }
        
        #map { 
            height: 100vh; 
            width: 100%; 
        }
        
        .map-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            z-index: 1000;
            pointer-events: none;
        }
        
        .map-title {
            background: rgba(255, 255, 255, 0.95);
            padding: 16px 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            text-align: center;
        }
        
        .map-title h1 {
            margin: 0;
            font-size: 24px;
            font-weight: 700;
            color: #100c08;
        }
        
        .map-title p {
            margin: 4px 0 0 0;
            font-size: 14px;
            color: #666;
            font-weight: 500;
        }
        
        /* Tour Card Popup */
        .tour-card {
            position: fixed;
            bottom: -100%;
            left: 0;
            right: 0;
            z-index: 2000;
            background: #fafafa;
            border-top-left-radius: 20px;
            border-top-right-radius: 20px;
            box-shadow: 0 -4px 30px rgba(0,0,0,0.2);
            transition: bottom 0.3s ease-out;
            max-height: 60vh;
            overflow: hidden;
        }
        
        .tour-card.visible {
            bottom: 0;
        }
        
        .tour-card-header {
            padding: 20px 24px 0 24px;
            position: relative;
        }
        
        .tour-card-drag-handle {
            width: 36px;
            height: 4px;
            background: rgba(16, 12, 8, 0.2);
            border-radius: 2px;
            margin: 0 auto 16px auto;
        }
        
        .tour-card-close {
            position: absolute;
            top: 16px;
            right: 20px;
            background: none;
            border: none;
            font-size: 24px;
            color: #666;
            cursor: pointer;
            padding: 4px;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .tour-card-close:hover {
            background: rgba(16, 12, 8, 0.1);
        }
        
        .tour-image {
            width: 100%;
            height: 160px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 18px;
            font-weight: 600;
        }
        
        .tour-card-content {
            padding: 0 24px 24px 24px;
        }
        
        .tour-title {
            font-size: 24px;
            font-weight: 700;
            color: #100c08;
            margin: 0 0 8px 0;
        }
        
        .tour-subtitle {
            font-size: 16px;
            color: #666;
            margin: 0 0 16px 0;
            font-weight: 500;
        }
        
        .tour-stats {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .tour-stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }
        
        .tour-stat-number {
            font-size: 20px;
            font-weight: 700;
            color: #100c08;
        }
        
        .tour-stat-label {
            font-size: 12px;
            color: #666;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .tour-description {
            font-size: 14px;
            line-height: 1.5;
            color: #444;
            margin-bottom: 24px;
        }
        
        .tour-actions {
            display: flex;
            gap: 12px;
        }
        
        .btn {
            flex: 1;
            padding: 14px 20px;
            border-radius: 10px;
            border: none;
            font-family: 'Gothic A1', sans-serif;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .btn-primary {
            background: #046307ff;
            color: #fafafa;
        }
        
        .btn-primary:hover {
            background: #035206;
            transform: translateY(-1px);
        }
        
        .btn-secondary {
            background: rgba(16, 12, 8, 0.1);
            color: #100c08;
        }
        
        .btn-secondary:hover {
            background: rgba(16, 12, 8, 0.15);
        }
        
        /* Legend */
        .legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.95);
            padding: 16px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            min-width: 200px;
        }
        
        .legend h3 {
            margin: 0 0 12px 0;
            font-size: 16px;
            font-weight: 600;
            color: #100c08;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            border: 2px solid rgba(255,255,255,0.8);
        }
        
        .legend-label {
            font-size: 14px;
            color: #444;
            font-weight: 500;
        }
        
        /* Loading state */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
            text-align: center;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
    <div class="map-overlay">
        <div class="map-title">
            <h1>LA Area Tours</h1>
            <p>Tap any highlighted area to explore</p>
        </div>
    </div>
    
    <div id="map"></div>
    
    <div class="legend">
        <h3>Available Tours</h3>
        <div id="legend-content">
            <!-- Legend items will be populated by JavaScript -->
        </div>
    </div>
    
    <div class="loading" id="loading">
        <div>Loading tours...</div>
    </div>
    
    <!-- Tour Card Popup -->
    <div class="tour-card" id="tour-card">
        <div class="tour-card-header">
            <div class="tour-card-drag-handle"></div>
            <button class="tour-card-close" onclick="closeTourCard()">&times;</button>
        </div>
        <div class="tour-card-content">
            <div class="tour-image" id="tour-image">
                ðŸ“¸ Tour Photo
            </div>
            <h2 class="tour-title" id="tour-title">Tour Name</h2>
            <p class="tour-subtitle" id="tour-subtitle">Neighborhood â€¢ City</p>
            
            <div class="tour-stats">
                <div class="tour-stat">
                    <div class="tour-stat-number" id="tour-stops">0</div>
                    <div class="tour-stat-label">Stops</div>
                </div>
                <div class="tour-stat">
                    <div class="tour-stat-number" id="tour-duration">0</div>
                    <div class="tour-stat-label">Hours</div>
                </div>
                <div class="tour-stat">
                    <div class="tour-stat-number" id="tour-distance">0</div>
                    <div class="tour-stat-label">Miles</div>
                </div>
            </div>
            
            <p class="tour-description" id="tour-description">
                Tour description will appear here...
            </p>
            
            <div class="tour-actions">
                <button class="btn btn-secondary" onclick="previewTour()">Preview</button>
                <button class="btn btn-primary" onclick="startTour()">Start Tour</button>
            </div>
        </div>
    </div>

    <script>
        let map;
        let tours = [];
        let activeTourCard = null;
        let tourPolygons = [];
        
        // Sample tour data - this will be replaced with Google Sheets data
        const sampleTours = [
            {
                id: 'pasadena-historic',
                name: 'Historic Pasadena',
                subtitle: 'South Pasadena â€¢ Architecture & Culture',
                description: 'Explore the rich architectural heritage and cultural landmarks of historic Pasadena, featuring beautiful Victorian homes, grand boulevards, and iconic civic buildings.',
                color: '#FF6B6B',
                stops: 22,
                duration: 2.5,
                distance: 8.3,
                addresses: [
                    '645 Prospect Crescent',
                    '657 Prospect Boulevard',
                    '4 Westmoreland Place',
                    '412 Glen Holly Dr, Pasadena, CA 91105',
                    '480 Glen Holly Drive',
                    '1540 Poppy Peak Dr. Pasadena, CA 91105',
                    '1150 La Loma Rd, Pasadena, CA 91105',
                    '711 S San Rafael Avenue',
                    '510 Lockehaven Street',
                    '391 S Orange Grove Blvd, Pasadena',
                    '125 South Grand Avenue',
                    '131 S St John Ave, Pasadena, CA 91105',
                    '443 S Raymond Avenue',
                    '99 South Raymond Avenue',
                    '300 East Green Street',
                    '46 LOS ROBLES',
                    '132 North Euclid',
                    '100 North Garfield Avenue',
                    '150 N MADISON AVE',
                    '585 E Colorado Blvd, Pasadena, CA 91101',
                    '606 E COLORADO',
                    '680 Colorado'
                ],
                photoUrl: null // Will use gradient placeholder
            }
            // Additional tours will be added here from Google Sheets
        ];

        function initMap() {
            // Initialize map centered on LA area
            map = new google.maps.Map(document.getElementById("map"), {
                zoom: 11,
                center: { lat: 34.0522, lng: -118.2437 },
                mapTypeControl: false,
                streetViewControl: false,
                fullscreenControl: false,
                styles: [
                    {
                        featureType: "poi",
                        elementType: "labels",
                        stylers: [{ visibility: "off" }]
                    },
                    {
                        featureType: "administrative",
                        elementType: "labels",
                        stylers: [{ visibility: "simplified" }]
                    }
                ]
            });

            // Process tour data and create overlays
            loadTours();
        }

        async function loadTours() {
            // For now, use sample data. Later this will fetch from Google Sheets
            tours = sampleTours;
            
            // Create tour area overlays
            for (const tour of tours) {
                await createTourOverlay(tour);
            }
            
            // Update legend
            updateLegend();
            
            // Hide loading
            document.getElementById('loading').style.display = 'none';
        }

        async function createTourOverlay(tour) {
            try {
                // Create road-following perimeter boundary
                await createRoadPerimeterBoundary(tour);
                
            } catch (error) {
                console.error('Error creating tour overlay:', error);
                // Fallback to simple boundary
                await createSimpleTourOverlay(tour);
            }
        }

        async function createRoadPerimeterBoundary(tour) {
            // Geocode all tour stops
            const geocoder = new google.maps.Geocoder();
            const allStops = [];
            
            console.log(`Creating road perimeter for ${tour.name} with ${tour.addresses.length} stops`);
            
            for (const address of tour.addresses) {
                try {
                    const result = await geocodeAddress(geocoder, address);
                    if (result) {
                        allStops.push(result);
                    }
                } catch (error) {
                    console.log(`Could not geocode: ${address}`);
                }
            }
            
            if (allStops.length < 3) {
                console.log('Not enough stops for perimeter, using simple boundary');
                return await createSimpleTourOverlay(tour);
            }
            
            // Find the outermost perimeter points (convex hull)
            const perimeterPoints = convexHull(allStops);
            console.log(`Found ${perimeterPoints.length} perimeter points`);
            
            // Get road routes between consecutive perimeter points
            const perimeterRoutes = [];
            const directionsService = new google.maps.DirectionsService();
            
            for (let i = 0; i < perimeterPoints.length; i++) {
                const start = perimeterPoints[i];
                const end = perimeterPoints[(i + 1) % perimeterPoints.length];
                
                try {
                    const route = await getRoutePoints(directionsService, start, end);
                    if (route && route.length > 0) {
                        // Add route points, but skip the last point to avoid duplication
                        perimeterRoutes.push(...route.slice(0, -1));
                    }
                } catch (error) {
                    console.log(`Failed to get route between perimeter points, using straight line`);
                    perimeterRoutes.push(start);
                }
            }
            
            if (perimeterRoutes.length < 3) {
                console.log('Failed to create road perimeter, using convex hull');
                perimeterRoutes.push(...perimeterPoints);
            }
            
            // Create the polygon overlay
            const polygon = new google.maps.Polygon({
                paths: perimeterRoutes,
                strokeColor: tour.color,
                strokeOpacity: 0.8,
                strokeWeight: 3,
                fillColor: tour.color,
                fillOpacity: 0.2,
                map: map,
                clickable: true
            });
            
            polygon.addListener('click', () => {
                showTourCard(tour);
            });
            
            tourPolygons.push({
                polygon: polygon,
                tour: tour
            });
            
            // Add markers for all stops (smaller ones for interior, larger for perimeter)
            addTourStopMarkers(allStops, perimeterPoints, tour.color);
            
            console.log(`Created road perimeter boundary with ${perimeterRoutes.length} points`);
        }

        async function getRoutePoints(directionsService, start, end) {
            return new Promise((resolve, reject) => {
                directionsService.route({
                    origin: start,
                    destination: end,
                    travelMode: google.maps.TravelMode.DRIVING,
                    optimizeWaypoints: false
                }, (result, status) => {
                    if (status === 'OK' && result.routes[0]) {
                        // Get detailed path points from the route
                        const path = result.routes[0].overview_path;
                        const routePoints = path.map(point => ({
                            lat: point.lat(),
                            lng: point.lng()
                        }));
                        resolve(routePoints);
                    } else {
                        reject(new Error(`Route failed: ${status}`));
                    }
                });
            });
        }

        function addTourStopMarkers(allStops, perimeterPoints, color) {
            // Create markers for all stops
            allStops.forEach((stop, index) => {
                const isPerimeter = perimeterPoints.some(p => 
                    Math.abs(p.lat - stop.lat) < 0.0001 && Math.abs(p.lng - stop.lng) < 0.0001
                );
                
                const markerSize = isPerimeter ? 20 : 14;
                const strokeWidth = isPerimeter ? 3 : 2;
                
                new google.maps.Marker({
                    position: stop,
                    map: map,
                    icon: {
                        url: `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(`
                            <svg width="${markerSize}" height="${markerSize}" viewBox="0 0 ${markerSize} ${markerSize}" xmlns="http://www.w3.org/2000/svg">
                                <circle cx="${markerSize/2}" cy="${markerSize/2}" r="${markerSize/2 - strokeWidth/2}" 
                                    fill="${color}" stroke="white" stroke-width="${strokeWidth}"/>
                                <text x="${markerSize/2}" y="${markerSize/2 + 3}" text-anchor="middle" 
                                    fill="white" font-size="${Math.floor(markerSize * 0.4)}" font-weight="bold">${index + 1}</text>
                            </svg>
                        `)}`,
                        scaledSize: new google.maps.Size(markerSize, markerSize),
                        anchor: new google.maps.Point(markerSize/2, markerSize/2)
                    },
                    title: `Stop ${index + 1}${isPerimeter ? ' (Perimeter)' : ''}`,
                    zIndex: isPerimeter ? 1000 : 900
                });
            });
        }

        function convexHull(points) {
            if (points.length < 3) return points;
            
            // Find the bottom-most point (and left-most in case of tie)
            let start = 0;
            for (let i = 1; i < points.length; i++) {
                if (points[i].lat < points[start].lat || 
                    (points[i].lat === points[start].lat && points[i].lng < points[start].lng)) {
                    start = i;
                }
            }
            
            // Sort points by polar angle with respect to start point
            const sorted = points.slice();
            const startPoint = sorted[start];
            sorted.splice(start, 1);
            
            sorted.sort((a, b) => {
                const angleA = Math.atan2(a.lat - startPoint.lat, a.lng - startPoint.lng);
                const angleB = Math.atan2(b.lat - startPoint.lat, b.lng - startPoint.lng);
                if (Math.abs(angleA - angleB) < 0.0001) {
                    // If angles are equal, sort by distance
                    const distA = distance(startPoint, a);
                    const distB = distance(startPoint, b);
                    return distA - distB;
                }
                return angleA - angleB;
            });
            
            // Build convex hull using Graham scan
            const hull = [startPoint];
            
            for (const point of sorted) {
                // Remove points that create clockwise turn
                while (hull.length > 1 && 
                       crossProduct(hull[hull.length-2], hull[hull.length-1], point) <= 0) {
                    hull.pop();
                }
                hull.push(point);
            }
            
            return hull;
        }

        function crossProduct(o, a, b) {
            return (a.lng - o.lng) * (b.lat - o.lat) - (a.lat - o.lat) * (b.lng - o.lng);
        }

        function distance(a, b) {
            return Math.sqrt(Math.pow(a.lat - b.lat, 2) + Math.pow(a.lng - b.lng, 2));
        }

        async function createSimpleTourOverlay(tour) {
            // Fallback method - simplified boundary
            const geocoder = new google.maps.Geocoder();
            const coordinates = [];
            
            for (const address of tour.addresses) {
                try {
                    const result = await geocodeAddress(geocoder, address);
                    if (result) coordinates.push(result);
                } catch (error) {
                    console.log(`Could not geocode: ${address}`);
                }
            }
            
            if (coordinates.length > 0) {
                const bounds = new google.maps.LatLngBounds();
                coordinates.forEach(coord => bounds.extend(coord));
                
                const ne = bounds.getNorthEast();
                const sw = bounds.getSouthWest();
                const padding = 0.003;
                
                const simpleBoundary = [
                    { lat: ne.lat() + padding, lng: sw.lng() - padding },
                    { lat: ne.lat() + padding, lng: ne.lng() + padding },
                    { lat: sw.lat() - padding, lng: ne.lng() + padding },
                    { lat: sw.lat() - padding, lng: sw.lng() - padding }
                ];
                
                const polygon = new google.maps.Polygon({
                    paths: simpleBoundary,
                    strokeColor: tour.color,
                    strokeOpacity: 0.8,
                    strokeWeight: 3,
                    fillColor: tour.color,
                    fillOpacity: 0.2,
                    map: map,
                    clickable: true
                });
                
                polygon.addListener('click', () => {
                    showTourCard(tour);
                });
                
                tourPolygons.push({
                    polygon: polygon,
                    tour: tour
                });
                
                addTourMarkers(coordinates.slice(0, 3), tour.color);
            }
        }

        function geocodeAddress(geocoder, address) {
            return new Promise((resolve, reject) => {
                // Add Pasadena context if not already specified
                const fullAddress = address.includes('Pasadena') ? address : `${address}, Pasadena, CA`;
                
                geocoder.geocode({ address: fullAddress }, (results, status) => {
                    if (status === 'OK' && results[0]) {
                        const location = results[0].geometry.location;
                        resolve({
                            lat: location.lat(),
                            lng: location.lng()
                        });
                    } else {
                        resolve(null);
                    }
                });
            });
        }

        function createTourBounds(coordinates) {
            if (coordinates.length < 3) return coordinates;
            
            // Create a more organic shape using convex hull with buffering
            const hull = convexHull(coordinates);
            
            // Add buffer around the convex hull to create more realistic boundaries
            return addBufferToPolygon(hull, 0.002); // ~200 meter buffer
        }
        
        function convexHull(points) {
            // Graham scan algorithm for convex hull
            if (points.length < 3) return points;
            
            // Find the bottom-most point (and left-most in case of tie)
            let start = 0;
            for (let i = 1; i < points.length; i++) {
                if (points[i].lat < points[start].lat || 
                    (points[i].lat === points[start].lat && points[i].lng < points[start].lng)) {
                    start = i;
                }
            }
            
            // Sort points by polar angle with respect to start point
            const sorted = points.slice();
            const startPoint = sorted[start];
            sorted.splice(start, 1);
            
            sorted.sort((a, b) => {
                const angleA = Math.atan2(a.lat - startPoint.lat, a.lng - startPoint.lng);
                const angleB = Math.atan2(b.lat - startPoint.lat, b.lng - startPoint.lng);
                if (angleA === angleB) {
                    // If angles are equal, sort by distance
                    const distA = distance(startPoint, a);
                    const distB = distance(startPoint, b);
                    return distA - distB;
                }
                return angleA - angleB;
            });
            
            // Build convex hull
            const hull = [startPoint];
            
            for (const point of sorted) {
                // Remove points that create clockwise turn
                while (hull.length > 1 && 
                       crossProduct(hull[hull.length-2], hull[hull.length-1], point) <= 0) {
                    hull.pop();
                }
                hull.push(point);
            }
            
            return hull;
        }
        
        function crossProduct(o, a, b) {
            return (a.lng - o.lng) * (b.lat - o.lat) - (a.lat - o.lat) * (b.lng - o.lng);
        }
        
        function distance(a, b) {
            return Math.sqrt(Math.pow(a.lat - b.lat, 2) + Math.pow(a.lng - b.lng, 2));
        }
        
        function addBufferToPolygon(hull, bufferSize) {
            // Create a buffer around the polygon by expanding outward
            const bufferedPoints = [];
            const numPoints = hull.length;
            
            for (let i = 0; i < numPoints; i++) {
                const current = hull[i];
                const next = hull[(i + 1) % numPoints];
                const prev = hull[(i - 1 + numPoints) % numPoints];
                
                // Calculate perpendicular vectors for buffering
                const toNext = normalize({ 
                    lat: next.lat - current.lat, 
                    lng: next.lng - current.lng 
                });
                const toPrev = normalize({ 
                    lat: prev.lat - current.lat, 
                    lng: prev.lng - current.lng 
                });
                
                // Calculate bisector (average of perpendiculars)
                const bisector = normalize({
                    lat: (perpendicular(toNext).lat + perpendicular(toPrev).lat) / 2,
                    lng: (perpendicular(toNext).lng + perpendicular(toPrev).lng) / 2
                });
                
                // Add buffered point
                bufferedPoints.push({
                    lat: current.lat + bisector.lat * bufferSize,
                    lng: current.lng + bisector.lng * bufferSize
                });
            }
            
            // Add some intermediate points for smoother curves
            const smoothedPoints = [];
            for (let i = 0; i < bufferedPoints.length; i++) {
                const current = bufferedPoints[i];
                const next = bufferedPoints[(i + 1) % bufferedPoints.length];
                
                smoothedPoints.push(current);
                
                // Add intermediate point for smoother curves
                smoothedPoints.push({
                    lat: (current.lat + next.lat) / 2,
                    lng: (current.lng + next.lng) / 2
                });
            }
            
            return smoothedPoints;
        }
        
        function normalize(vector) {
            const length = Math.sqrt(vector.lat * vector.lat + vector.lng * vector.lng);
            if (length === 0) return { lat: 0, lng: 0 };
            return { lat: vector.lat / length, lng: vector.lng / length };
        }
        
        function perpendicular(vector) {
            return { lat: -vector.lng, lng: vector.lat };
        }

        function addTourMarkers(coordinates, color) {
            // This function is replaced by addTourStopMarkers
            // Kept for compatibility
        }

        function updateLegend() {
            const legendContent = document.getElementById('legend-content');
            legendContent.innerHTML = '';
            
            tours.forEach(tour => {
                const legendItem = document.createElement('div');
                legendItem.className = 'legend-item';
                legendItem.innerHTML = `
                    <div class="legend-color" style="background-color: ${tour.color}"></div>
                    <div class="legend-label">${tour.name}</div>
                `;
                legendContent.appendChild(legendItem);
            });
        }

        function showTourCard(tour) {
            activeTourCard = tour;
            
            // Update tour card content
            document.getElementById('tour-title').textContent = tour.name;
            document.getElementById('tour-subtitle').textContent = tour.subtitle;
            document.getElementById('tour-description').textContent = tour.description;
            document.getElementById('tour-stops').textContent = tour.stops;
            document.getElementById('tour-duration').textContent = tour.duration;
            document.getElementById('tour-distance').textContent = tour.distance;
            
            // Update image (placeholder for now)
            const tourImage = document.getElementById('tour-image');
            if (tour.photoUrl) {
                tourImage.style.backgroundImage = `url(${tour.photoUrl})`;
                tourImage.style.backgroundSize = 'cover';
                tourImage.style.backgroundPosition = 'center';
                tourImage.textContent = '';
            } else {
                tourImage.style.backgroundImage = `linear-gradient(135deg, ${tour.color}88, ${tour.color}cc)`;
                tourImage.textContent = 'ðŸ“¸ Tour Photo';
            }
            
            // Show tour card
            document.getElementById('tour-card').classList.add('visible');
        }

        function closeTourCard() {
            document.getElementById('tour-card').classList.remove('visible');
            activeTourCard = null;
        }

        function previewTour() {
            if (!activeTourCard) return;
            
            // This could show a detailed route preview or photo gallery
            alert(`Preview functionality for ${activeTourCard.name} - coming soon!`);
        }

        function startTour() {
            if (!activeTourCard) return;
            
            // Send message to Draftbit app OR navigate to navigation map
            const tourData = {
                action: 'start_tour',
                tourId: activeTourCard.id,
                tourName: activeTourCard.name,
                addresses: activeTourCard.addresses
            };
            
            // Option 1: Send to parent app via PostMessage (if in webview)
            if (window.ReactNativeWebView) {
                window.ReactNativeWebView.postMessage(JSON.stringify(tourData));
            }
            
            // Option 2: Navigate to navigation map with parameters
            const navigationUrl = `./navigation.html?tour=${encodeURIComponent(JSON.stringify(tourData))}`;
            window.location.href = navigationUrl;
            
            // Option 3: Custom URL scheme (uncomment if using deep links)
            // window.location.href = `laapp://start-tour?id=${activeTourCard.id}`;
        }

        // Touch handling for mobile
        let startY = 0;
        document.getElementById('tour-card').addEventListener('touchstart', (e) => {
            startY = e.touches[0].clientY;
        });

        document.getElementById('tour-card').addEventListener('touchmove', (e) => {
            const currentY = e.touches[0].clientY;
            const diffY = startY - currentY;
            
            if (diffY < -100) { // Swipe down to close
                closeTourCard();
            }
        });
    </script>

    <script async defer
        src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDDdD8BAz34j_0zv-G3qJKTP5sKQn7PQ1w&callback=initMap">
    </script>
</body>
</html>
