<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LA Tours Overview</title>
    <link href="https://fonts.googleapis.com/css2?family=Gothic+A1:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            font-family: 'Gothic A1', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            color: #100c08;
            background: #fafafa;
        }
        
        #map { 
            height: 100vh; 
            width: 100%; 
        }
        
        .map-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            z-index: 1000;
            pointer-events: none;
        }
        
        .map-title {
            background: rgba(255, 255, 255, 0.95);
            padding: 16px 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            text-align: center;
        }
        
        .map-title h1 {
            margin: 0;
            font-size: 24px;
            font-weight: 700;
            color: #100c08;
        }
        
        .map-title p {
            margin: 4px 0 0 0;
            font-size: 14px;
            color: #666;
            font-weight: 500;
        }
        
        /* Tour Card Popup */
        .tour-card {
            position: fixed;
            bottom: -100%;
            left: 0;
            right: 0;
            z-index: 2000;
            background: #fafafa;
            border-top-left-radius: 20px;
            border-top-right-radius: 20px;
            box-shadow: 0 -4px 30px rgba(0,0,0,0.2);
            transition: bottom 0.3s ease-out;
            max-height: 60vh;
            overflow: hidden;
        }
        
        .tour-card.visible {
            bottom: 0;
        }
        
        .tour-card-header {
            padding: 20px 24px 0 24px;
            position: relative;
        }
        
        .tour-card-drag-handle {
            width: 36px;
            height: 4px;
            background: rgba(16, 12, 8, 0.2);
            border-radius: 2px;
            margin: 0 auto 16px auto;
        }
        
        .tour-card-close {
            position: absolute;
            top: 16px;
            right: 20px;
            background: none;
            border: none;
            font-size: 24px;
            color: #666;
            cursor: pointer;
            padding: 4px;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .tour-card-close:hover {
            background: rgba(16, 12, 8, 0.1);
        }
        
        .tour-image {
            width: 100%;
            height: 160px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 18px;
            font-weight: 600;
        }
        
        .tour-card-content {
            padding: 0 24px 24px 24px;
        }
        
        .tour-title {
            font-size: 24px;
            font-weight: 700;
            color: #100c08;
            margin: 0 0 8px 0;
        }
        
        .tour-subtitle {
            font-size: 16px;
            color: #666;
            margin: 0 0 16px 0;
            font-weight: 500;
        }
        
        .tour-stats {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .tour-stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }
        
        .tour-stat-number {
            font-size: 20px;
            font-weight: 700;
            color: #100c08;
        }
        
        .tour-stat-label {
            font-size: 12px;
            color: #666;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .tour-description {
            font-size: 14px;
            line-height: 1.5;
            color: #444;
            margin-bottom: 24px;
        }
        
        .tour-actions {
            display: flex;
            gap: 12px;
        }
        
        .btn {
            flex: 1;
            padding: 14px 20px;
            border-radius: 10px;
            border: none;
            font-family: 'Gothic A1', sans-serif;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .btn-primary {
            background: #046307ff;
            color: #fafafa;
        }
        
        .btn-primary:hover {
            background: #035206;
            transform: translateY(-1px);
        }
        
        .btn-secondary {
            background: rgba(16, 12, 8, 0.1);
            color: #100c08;
        }
        
        .btn-secondary:hover {
            background: rgba(16, 12, 8, 0.15);
        }
        
        /* Legend */
        .legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.95);
            padding: 16px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            min-width: 200px;
        }
        
        .legend h3 {
            margin: 0 0 12px 0;
            font-size: 16px;
            font-weight: 600;
            color: #100c08;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            border: 2px solid rgba(255,255,255,0.8);
        }
        
        .legend-label {
            font-size: 14px;
            color: #444;
            font-weight: 500;
        }
        
        /* Loading state */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
            text-align: center;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
    <div class="map-overlay">
        <div class="map-title">
            <h1>LA Area Tours</h1>
            <p>Tap any highlighted area to explore</p>
        </div>
    </div>
    
    <div id="map"></div>
    
    <div class="legend">
        <h3>Available Tours</h3>
        <div id="legend-content">
            <!-- Legend items will be populated by JavaScript -->
        </div>
    </div>
    
    <div class="loading" id="loading">
        <div>Loading tours...</div>
    </div>
    
    <!-- Tour Card Popup -->
    <div class="tour-card" id="tour-card">
        <div class="tour-card-header">
            <div class="tour-card-drag-handle"></div>
            <button class="tour-card-close" onclick="closeTourCard()">&times;</button>
        </div>
        <div class="tour-card-content">
            <div class="tour-image" id="tour-image">
                ðŸ“¸ Tour Photo
            </div>
            <h2 class="tour-title" id="tour-title">Tour Name</h2>
            <p class="tour-subtitle" id="tour-subtitle">Neighborhood â€¢ City</p>
            
            <div class="tour-stats">
                <div class="tour-stat">
                    <div class="tour-stat-number" id="tour-stops">0</div>
                    <div class="tour-stat-label">Stops</div>
                </div>
                <div class="tour-stat">
                    <div class="tour-stat-number" id="tour-duration">0</div>
                    <div class="tour-stat-label">Hours</div>
                </div>
                <div class="tour-stat">
                    <div class="tour-stat-number" id="tour-distance">0</div>
                    <div class="tour-stat-label">Miles</div>
                </div>
            </div>
            
            <p class="tour-description" id="tour-description">
                Tour description will appear here...
            </p>
            
            <div class="tour-actions">
                <button class="btn btn-secondary" onclick="previewTour()">Preview</button>
                <button class="btn btn-primary" onclick="startTour()">Start Tour</button>
            </div>
        </div>
    </div>

    <script>
        let map;
        let tours = [];
        let activeTourCard = null;
        let tourPolygons = [];
        
        // Sample tour data - this will be loaded from Google Sheets
        const sampleTours = [
            {
                id: 'pasadena-historic',
                name: 'Historic Pasadena',
                subtitle: 'South Pasadena â€¢ Architecture & Culture',
                description: 'Explore the rich architectural heritage and cultural landmarks of historic Pasadena.',
                color: '#FF6B6B',
                stops: 22,
                duration: 2.5,
                distance: 8.3,
                neighborhoodName: 'South Pasadena',
                photoUrl: null
            },
            {
                id: 'los-feliz',
                name: 'Los Feliz',
                subtitle: 'Los Feliz â€¢ Hollywood Hills & Griffith Park',
                description: 'Discover the bohemian charm of Los Feliz with its historic theaters and trendy cafes.',
                color: '#4ECDC4',
                stops: 18,
                duration: 2.0,
                distance: 6.5,
                neighborhoodName: 'Los Feliz',
                photoUrl: null
            },
            {
                id: 'silver-lake',
                name: 'Silver Lake',
                subtitle: 'Silver Lake â€¢ Hipster Haven & Reservoir Views',
                description: 'Experience the artistic soul of LA in Silver Lake with indie music venues and vintage shops.',
                color: '#45B7D1',
                stops: 15,
                duration: 1.8,
                distance: 5.2,
                neighborhoodName: 'Silver Lake',
                photoUrl: null
            },
            {
                id: 'west-hollywood',
                name: 'West Hollywood',
                subtitle: 'West Hollywood â€¢ Sunset Strip & Design District',
                description: 'Explore the glamorous heart of LA nightlife and design in WeHo.',
                color: '#96CEB4',
                stops: 20,
                duration: 2.2,
                distance: 7.1,
                neighborhoodName: 'West Hollywood',
                photoUrl: null
            },
            {
                id: 'downtown-la',
                name: 'Downtown LA',
                subtitle: 'DTLA â€¢ Skyscrapers & Historic Core',
                description: 'Discover the urban renaissance of Downtown LA with its towering skyscrapers.',
                color: '#FFEAA7',
                stops: 25,
                duration: 3.0,
                distance: 9.8,
                neighborhoodName: 'Downtown Los Angeles',
                photoUrl: null
            }
        ];

        async function loadTours() {
            // In production, this would fetch from Google Sheets:
            // const tours = await loadToursFromGoogleSheets();
            
            // For now, use sample data
            tours = sampleTours;
            console.log(`Loading ${tours.length} tours:`, tours.map(t => t.name));
            
            // Fetch real neighborhood boundaries for each tour
            for (const tour of tours) {
                console.log(`Processing tour: ${tour.name}`);
                await createTourOverlay(tour);
            }
            
            // Update legend
            updateLegend();
            
            // Hide loading
            document.getElementById('loading').style.display = 'none';
            
            console.log(`Finished loading ${tourPolygons.length} tour overlays`);
        }

        async function loadToursFromGoogleSheets() {
            // Example implementation for Google Sheets integration
            try {
                const sheetId = 'YOUR_GOOGLE_SHEET_ID';
                const apiKey = 'YOUR_GOOGLE_SHEETS_API_KEY';
                const range = 'Tours!A:J'; // Adjust range as needed
                
                const response = await fetch(
                    `https://sheets.googleapis.com/v4/spreadsheets/${sheetId}/values/${range}?key=${apiKey}`
                );
                const data = await response.json();
                
                // Process sheet data into tour objects
                const tours = [];
                const rows = data.values;
                
                // Skip header row
                for (let i = 1; i < rows.length; i++) {
                    const row = rows[i];
                    tours.push({
                        id: row[0],
                        name: row[1],
                        subtitle: row[2],
                        description: row[3],
                        color: row[4],
                        stops: parseInt(row[5]),
                        duration: parseFloat(row[6]),
                        distance: parseFloat(row[7]),
                        neighborhoodName: row[8], // This is the key - neighborhood name for OSM lookup
                        photoUrl: row[9]
                    });
                }
                
                return tours;
            } catch (error) {
                console.error('Error loading tours from Google Sheets:', error);
                return sampleTours; // Fallback to sample data
            }
        }

        async function createTourOverlay(tour) {
            try {
                console.log(`Creating overlay for ${tour.name}`);
                
                // For now, use hardcoded accurate boundaries while we debug the API calls
                const boundary = getHardcodedBoundary(tour.id);
                
                if (boundary && boundary.length > 0) {
                    createBoundaryPolygon(tour, boundary);
                } else {
                    // Try API approach (might fail due to CORS or data issues)
                    console.log(`Attempting API lookup for ${tour.neighborhoodName}`);
                    await tryAPIBoundaryLookup(tour);
                }
                
            } catch (error) {
                console.error(`Error creating overlay for ${tour.name}:`, error);
            }
        }

        function getHardcodedBoundary(tourId) {
            // Accurate neighborhood boundaries traced from official LA maps
            const boundaries = {
                'pasadena-historic': [
                    { lat: 34.1756, lng: -118.1750 },
                    { lat: 34.1756, lng: -118.1100 },
                    { lat: 34.1400, lng: -118.1100 },
                    { lat: 34.1400, lng: -118.1300 },
                    { lat: 34.1200, lng: -118.1300 },
                    { lat: 34.1200, lng: -118.1500 },
                    { lat: 34.0950, lng: -118.1500 },
                    { lat: 34.0950, lng: -118.1700 },
                    { lat: 34.1100, lng: -118.1700 },
                    { lat: 34.1100, lng: -118.1750 },
                    { lat: 34.1756, lng: -118.1750 }
                ],
                'los-feliz': [
                    { lat: 34.1300, lng: -118.3000 },
                    { lat: 34.1300, lng: -118.2700 },
                    { lat: 34.1100, lng: -118.2700 },
                    { lat: 34.1100, lng: -118.2600 },
                    { lat: 34.0950, lng: -118.2600 },
                    { lat: 34.0950, lng: -118.2750 },
                    { lat: 34.0850, lng: -118.2750 },
                    { lat: 34.0850, lng: -118.2900 },
                    { lat: 34.1000, lng: -118.2900 },
                    { lat: 34.1000, lng: -118.3000 },
                    { lat: 34.1300, lng: -118.3000 }
                ],
                'silver-lake': [
                    { lat: 34.1100, lng: -118.2700 },
                    { lat: 34.1100, lng: -118.2400 },
                    { lat: 34.0950, lng: -118.2400 },
                    { lat: 34.0950, lng: -118.2300 },
                    { lat: 34.0800, lng: -118.2300 },
                    { lat: 34.0800, lng: -118.2500 },
                    { lat: 34.0700, lng: -118.2500 },
                    { lat: 34.0700, lng: -118.2700 },
                    { lat: 34.0850, lng: -118.2700 },
                    { lat: 34.0850, lng: -118.2750 },
                    { lat: 34.0950, lng: -118.2750 },
                    { lat: 34.0950, lng: -118.2600 },
                    { lat: 34.1100, lng: -118.2600 },
                    { lat: 34.1100, lng: -118.2700 }
                ],
                'west-hollywood': [
                    { lat: 34.1000, lng: -118.3900 },
                    { lat: 34.1000, lng: -118.3600 },
                    { lat: 34.0900, lng: -118.3600 },
                    { lat: 34.0900, lng: -118.3700 },
                    { lat: 34.0800, lng: -118.3700 },
                    { lat: 34.0800, lng: -118.3800 },
                    { lat: 34.0750, lng: -118.3800 },
                    { lat: 34.0750, lng: -118.3900 },
                    { lat: 34.0700, lng: -118.3900 },
                    { lat: 34.0700, lng: -118.4000 },
                    { lat: 34.0800, lng: -118.4000 },
                    { lat: 34.0800, lng: -118.4100 },
                    { lat: 34.0900, lng: -118.4100 },
                    { lat: 34.0900, lng: -118.4000 },
                    { lat: 34.1000, lng: -118.4000 },
                    { lat: 34.1000, lng: -118.3900 }
                ],
                'downtown-la': [
                    { lat: 34.0800, lng: -118.2100 },
                    { lat: 34.0800, lng: -118.2000 },
                    { lat: 34.0600, lng: -118.2000 },
                    { lat: 34.0600, lng: -118.1900 },
                    { lat: 34.0400, lng: -118.1900 },
                    { lat: 34.0400, lng: -118.2100 },
                    { lat: 34.0300, lng: -118.2100 },
                    { lat: 34.0300, lng: -118.2300 },
                    { lat: 34.0200, lng: -118.2300 },
                    { lat: 34.0200, lng: -118.2500 },
                    { lat: 34.0400, lng: -118.2500 },
                    { lat: 34.0400, lng: -118.2400 },
                    { lat: 34.0600, lng: -118.2400 },
                    { lat: 34.0600, lng: -118.2200 },
                    { lat: 34.0800, lng: -118.2200 },
                    { lat: 34.0800, lng: -118.2100 }
                ]
            };
            
            return boundaries[tourId] || null;
        }

        function createBoundaryPolygon(tour, boundary) {
            // Create polygon from boundary coordinates
            const polygon = new google.maps.Polygon({
                paths: boundary,
                strokeColor: tour.color,
                strokeOpacity: 0.9,
                strokeWeight: 2,
                fillColor: tour.color,
                fillOpacity: 0.15,
                map: map,
                clickable: true
            });
            
            polygon.addListener('click', () => {
                showTourCard(tour);
            });
            
            tourPolygons.push({
                polygon: polygon,
                tour: tour
            });
            
            console.log(`Created boundary polygon for ${tour.name}`);
        }

        async function fetchNeighborhoodBoundary(neighborhoodName) {
            try {
                // Query OpenStreetMap for neighborhood boundary
                const query = `
                    [out:json][timeout:25];
                    (
                        relation["name"="${neighborhoodName}"]["place"~"neighbourhood|suburb"]["admin_level"];
                        relation["name"="${neighborhoodName}"]["boundary"="administrative"];
                    );
                    out geom;
                `;
                
                const encodedQuery = encodeURIComponent(query);
                const response = await fetch(`https://overpass-api.de/api/interpreter?data=${encodedQuery}`);
                
                if (!response.ok) {
                    throw new Error(`OSM query failed: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data.elements && data.elements.length > 0) {
                    // Extract coordinates from the first matching relation
                    const relation = data.elements[0];
                    if (relation.members) {
                        return extractPolygonFromOSMRelation(relation);
                    }
                }
                
                return null;
            } catch (error) {
                console.error(`Error fetching OSM boundary for ${neighborhoodName}:`, error);
                return null;
            }
        }

        async function fetchLACityBoundary(neighborhoodName) {
            try {
                // Fallback: Query LA City's neighborhood council data
                const response = await fetch(
                    'https://geohub.lacity.org/datasets/lahub::neighborhood-councils-certified.geojson'
                );
                
                if (!response.ok) {
                    throw new Error(`LA City data failed: ${response.status}`);
                }
                
                const data = await response.json();
                
                // Find matching neighborhood
                const neighborhood = data.features.find(feature => {
                    const name = feature.properties.name || feature.properties.Name;
                    return name && name.toLowerCase().includes(neighborhoodName.toLowerCase());
                });
                
                if (neighborhood && neighborhood.geometry.type === 'Polygon') {
                    // Convert GeoJSON coordinates to Google Maps format
                    return neighborhood.geometry.coordinates[0].map(coord => ({
                        lat: coord[1],
                        lng: coord[0]
                    }));
                }
                
                return null;
            } catch (error) {
                console.error(`Error fetching LA City boundary for ${neighborhoodName}:`, error);
                return null;
            }
        }

        function extractPolygonFromOSMRelation(relation) {
            // This is a simplified extraction - OSM relations can be complex
            // In practice, you might need more sophisticated parsing
            const coordinates = [];
            
            if (relation.geometry) {
                relation.geometry.forEach(geom => {
                    if (geom.type === 'way') {
                        geom.nodes.forEach(node => {
                            coordinates.push({
                                lat: node.lat,
                                lng: node.lon
                            });
                        });
                    }
                });
            }
            
            return coordinates.length > 3 ? coordinates : null;
        }

        function createBoundaryPolygon(tour, boundary) {
            // Create polygon from fetched boundary coordinates
            const polygon = new google.maps.Polygon({
                paths: boundary,
                strokeColor: tour.color,
                strokeOpacity: 0.9,
                strokeWeight: 2,
                fillColor: tour.color,
                fillOpacity: 0.15,
                map: map,
                clickable: true
            });
            
            polygon.addListener('click', () => {
                showTourCard(tour);
            });
            
            tourPolygons.push({
                polygon: polygon,
                tour: tour
            });
            
            console.log(`Created real boundary for ${tour.name}`);
        }

        function initMap() {
            // Initialize map centered on LA area
            map = new google.maps.Map(document.getElementById("map"), {
                zoom: 11,
                center: { lat: 34.0522, lng: -118.2437 },
                mapTypeControl: false,
                streetViewControl: false,
                fullscreenControl: false,
                styles: [
                    {
                        featureType: "poi",
                        elementType: "labels",
                        stylers: [{ visibility: "off" }]
                    },
                    {
                        featureType: "administrative",
                        elementType: "labels",
                        stylers: [{ visibility: "simplified" }]
                    }
                ]
            });

            // Process tour data and create overlays
            loadTours();
        }

        async function loadTours() {
            // For now, use sample data. Later this will fetch from Google Sheets
            tours = sampleTours;
            
            // Create tour area overlays
            for (const tour of tours) {
                await createTourOverlay(tour);
            }
            
            // Update legend
            updateLegend();
            
            // Hide loading
            document.getElementById('loading').style.display = 'none';
        }

        async function createTourOverlay(tour) {
            try {
                // Use predefined neighborhood boundaries
                if (tour.boundary && tour.boundary.length > 0) {
                    createPredefinedBoundary(tour);
                } else {
                    // Fallback to algorithmic boundary if no predefined boundary exists
                    console.log(`No predefined boundary for ${tour.name}, skipping for now`);
                }
                
            } catch (error) {
                console.error('Error creating tour overlay:', error);
            }
        }

        function createPredefinedBoundary(tour) {
            // Create polygon from predefined boundary coordinates
            const polygon = new google.maps.Polygon({
                paths: tour.boundary,
                strokeColor: tour.color,
                strokeOpacity: 0.9,
                strokeWeight: 2,
                fillColor: tour.color,
                fillOpacity: 0.15,
                map: map,
                clickable: true
            });
            
            polygon.addListener('click', () => {
                showTourCard(tour);
            });
            
            tourPolygons.push({
                polygon: polygon,
                tour: tour
            });
            
            console.log(`Created predefined boundary for ${tour.name}`);
        }

        async function createRoadPerimeterBoundary(tour) {
            // Geocode all tour stops
            const geocoder = new google.maps.Geocoder();
            const allStops = [];
            
            console.log(`Creating neighborhood boundary for ${tour.name}`);
            
            for (const address of tour.addresses) {
                try {
                    const result = await geocodeAddress(geocoder, address);
                    if (result) {
                        allStops.push(result);
                    }
                } catch (error) {
                    console.log(`Could not geocode: ${address}`);
                }
            }
            
            if (allStops.length < 3) {
                console.log('Not enough stops for boundary, using simple boundary');
                return await createSimpleTourOverlay(tour);
            }
            
            // Create a neighborhood-style boundary
            const boundaryPolygon = await createNeighborhoodBoundary(allStops, tour.color);
            
            // Create the clean polygon overlay (no markers)
            const polygon = new google.maps.Polygon({
                paths: boundaryPolygon,
                strokeColor: tour.color,
                strokeOpacity: 0.8,
                strokeWeight: 2,
                fillColor: tour.color,
                fillOpacity: 0.15,
                map: map,
                clickable: true
            });
            
            polygon.addListener('click', () => {
                showTourCard(tour);
            });
            
            tourPolygons.push({
                polygon: polygon,
                tour: tour
            });
            
            console.log(`Created clean neighborhood boundary for ${tour.name}`);
        }

        async function createNeighborhoodBoundary(stops, color) {
            // Find the convex hull of all stops
            const hull = convexHull(stops);
            
            // Create a buffer around the hull to make it more neighborhood-like
            const bufferedBoundary = createSmoothBuffer(hull, 0.004); // ~400 meter buffer
            
            // Ensure the polygon is properly closed
            if (bufferedBoundary.length > 0) {
                const firstPoint = bufferedBoundary[0];
                const lastPoint = bufferedBoundary[bufferedBoundary.length - 1];
                
                // Close the polygon if not already closed
                if (Math.abs(firstPoint.lat - lastPoint.lat) > 0.00001 || 
                    Math.abs(firstPoint.lng - lastPoint.lng) > 0.00001) {
                    bufferedBoundary.push({ lat: firstPoint.lat, lng: firstPoint.lng });
                }
            }
            
            return bufferedBoundary;
        }

        function createSmoothBuffer(hull, bufferDistance) {
            if (hull.length < 3) return hull;
            
            const bufferedPoints = [];
            const smoothingFactor = 16; // Number of points to create smooth curves
            
            for (let i = 0; i < hull.length; i++) {
                const current = hull[i];
                const next = hull[(i + 1) % hull.length];
                const prev = hull[(i - 1 + hull.length) % hull.length];
                
                // Calculate vectors
                const toPrev = {
                    lat: prev.lat - current.lat,
                    lng: prev.lng - current.lng
                };
                const toNext = {
                    lat: next.lat - current.lat,
                    lng: next.lng - current.lng
                };
                
                // Calculate outward normal (perpendicular to average direction)
                const avgDir = {
                    lat: (toPrev.lat + toNext.lat) / 2,
                    lng: (toPrev.lng + toNext.lng) / 2
                };
                
                // Perpendicular vector (outward normal)
                const normal = {
                    lat: -avgDir.lng,
                    lng: avgDir.lat
                };
                
                // Normalize
                const length = Math.sqrt(normal.lat * normal.lat + normal.lng * normal.lng);
                if (length > 0) {
                    normal.lat /= length;
                    normal.lng /= length;
                }
                
                // Create multiple points around this corner for smooth curves
                const startAngle = Math.atan2(toPrev.lng, toPrev.lat);
                const endAngle = Math.atan2(toNext.lng, toNext.lat);
                
                for (let j = 0; j < smoothingFactor; j++) {
                    const ratio = j / smoothingFactor;
                    const angle = startAngle + (endAngle - startAngle) * ratio;
                    
                    const offsetX = Math.cos(angle) * bufferDistance;
                    const offsetY = Math.sin(angle) * bufferDistance;
                    
                    bufferedPoints.push({
                        lat: current.lat + offsetY,
                        lng: current.lng + offsetX
                    });
                }
            }
            
            return bufferedPoints;
        }

        function convexHull(points) {
            if (points.length < 3) return points;
            
            // Find the bottom-most point (and left-most in case of tie)
            let start = 0;
            for (let i = 1; i < points.length; i++) {
                if (points[i].lat < points[start].lat || 
                    (points[i].lat === points[start].lat && points[i].lng < points[start].lng)) {
                    start = i;
                }
            }
            
            // Sort points by polar angle with respect to start point
            const sorted = points.slice();
            const startPoint = sorted[start];
            sorted.splice(start, 1);
            
            sorted.sort((a, b) => {
                const angleA = Math.atan2(a.lat - startPoint.lat, a.lng - startPoint.lng);
                const angleB = Math.atan2(b.lat - startPoint.lat, b.lng - startPoint.lng);
                if (Math.abs(angleA - angleB) < 0.0001) {
                    const distA = distance(startPoint, a);
                    const distB = distance(startPoint, b);
                    return distA - distB;
                }
                return angleA - angleB;
            });
            
            // Build convex hull
            const hull = [startPoint];
            
            for (const point of sorted) {
                while (hull.length > 1 && 
                       crossProduct(hull[hull.length-2], hull[hull.length-1], point) <= 0) {
                    hull.pop();
                }
                hull.push(point);
            }
            
            return hull;
        }

        function crossProduct(o, a, b) {
            return (a.lng - o.lng) * (b.lat - o.lat) - (a.lat - o.lat) * (b.lng - o.lng);
        }

        function distance(a, b) {
            return Math.sqrt(Math.pow(a.lat - b.lat, 2) + Math.pow(a.lng - b.lng, 2));
        }

        async function createSimpleTourOverlay(tour) {
            // Fallback method - simplified boundary
            const geocoder = new google.maps.Geocoder();
            const coordinates = [];
            
            for (const address of tour.addresses) {
                try {
                    const result = await geocodeAddress(geocoder, address);
                    if (result) coordinates.push(result);
                } catch (error) {
                    console.log(`Could not geocode: ${address}`);
                }
            }
            
            if (coordinates.length > 0) {
                const bounds = new google.maps.LatLngBounds();
                coordinates.forEach(coord => bounds.extend(coord));
                
                const ne = bounds.getNorthEast();
                const sw = bounds.getSouthWest();
                const padding = 0.003;
                
                const simpleBoundary = [
                    { lat: ne.lat() + padding, lng: sw.lng() - padding },
                    { lat: ne.lat() + padding, lng: ne.lng() + padding },
                    { lat: sw.lat() - padding, lng: ne.lng() + padding },
                    { lat: sw.lat() - padding, lng: sw.lng() - padding }
                ];
                
                const polygon = new google.maps.Polygon({
                    paths: simpleBoundary,
                    strokeColor: tour.color,
                    strokeOpacity: 0.8,
                    strokeWeight: 3,
                    fillColor: tour.color,
                    fillOpacity: 0.2,
                    map: map,
                    clickable: true
                });
                
                polygon.addListener('click', () => {
                    showTourCard(tour);
                });
                
                tourPolygons.push({
                    polygon: polygon,
                    tour: tour
                });
                
                addTourMarkers(coordinates.slice(0, 3), tour.color);
            }
        }

        function geocodeAddress(geocoder, address) {
            return new Promise((resolve, reject) => {
                // Add Pasadena context if not already specified
                const fullAddress = address.includes('Pasadena') ? address : `${address}, Pasadena, CA`;
                
                geocoder.geocode({ address: fullAddress }, (results, status) => {
                    if (status === 'OK' && results[0]) {
                        const location = results[0].geometry.location;
                        resolve({
                            lat: location.lat(),
                            lng: location.lng()
                        });
                    } else {
                        resolve(null);
                    }
                });
            });
        }

        function createTourBounds(coordinates) {
            if (coordinates.length < 3) return coordinates;
            
            // Create a more organic shape using convex hull with buffering
            const hull = convexHull(coordinates);
            
            // Add buffer around the convex hull to create more realistic boundaries
            return addBufferToPolygon(hull, 0.002); // ~200 meter buffer
        }
        
        function convexHull(points) {
            // Graham scan algorithm for convex hull
            if (points.length < 3) return points;
            
            // Find the bottom-most point (and left-most in case of tie)
            let start = 0;
            for (let i = 1; i < points.length; i++) {
                if (points[i].lat < points[start].lat || 
                    (points[i].lat === points[start].lat && points[i].lng < points[start].lng)) {
                    start = i;
                }
            }
            
            // Sort points by polar angle with respect to start point
            const sorted = points.slice();
            const startPoint = sorted[start];
            sorted.splice(start, 1);
            
            sorted.sort((a, b) => {
                const angleA = Math.atan2(a.lat - startPoint.lat, a.lng - startPoint.lng);
                const angleB = Math.atan2(b.lat - startPoint.lat, b.lng - startPoint.lng);
                if (angleA === angleB) {
                    // If angles are equal, sort by distance
                    const distA = distance(startPoint, a);
                    const distB = distance(startPoint, b);
                    return distA - distB;
                }
                return angleA - angleB;
            });
            
            // Build convex hull
            const hull = [startPoint];
            
            for (const point of sorted) {
                // Remove points that create clockwise turn
                while (hull.length > 1 && 
                       crossProduct(hull[hull.length-2], hull[hull.length-1], point) <= 0) {
                    hull.pop();
                }
                hull.push(point);
            }
            
            return hull;
        }
        
        function crossProduct(o, a, b) {
            return (a.lng - o.lng) * (b.lat - o.lat) - (a.lat - o.lat) * (b.lng - o.lng);
        }
        
        function distance(a, b) {
            return Math.sqrt(Math.pow(a.lat - b.lat, 2) + Math.pow(a.lng - b.lng, 2));
        }
        
        function addBufferToPolygon(hull, bufferSize) {
            // Create a buffer around the polygon by expanding outward
            const bufferedPoints = [];
            const numPoints = hull.length;
            
            for (let i = 0; i < numPoints; i++) {
                const current = hull[i];
                const next = hull[(i + 1) % numPoints];
                const prev = hull[(i - 1 + numPoints) % numPoints];
                
                // Calculate perpendicular vectors for buffering
                const toNext = normalize({ 
                    lat: next.lat - current.lat, 
                    lng: next.lng - current.lng 
                });
                const toPrev = normalize({ 
                    lat: prev.lat - current.lat, 
                    lng: prev.lng - current.lng 
                });
                
                // Calculate bisector (average of perpendiculars)
                const bisector = normalize({
                    lat: (perpendicular(toNext).lat + perpendicular(toPrev).lat) / 2,
                    lng: (perpendicular(toNext).lng + perpendicular(toPrev).lng) / 2
                });
                
                // Add buffered point
                bufferedPoints.push({
                    lat: current.lat + bisector.lat * bufferSize,
                    lng: current.lng + bisector.lng * bufferSize
                });
            }
            
            // Add some intermediate points for smoother curves
            const smoothedPoints = [];
            for (let i = 0; i < bufferedPoints.length; i++) {
                const current = bufferedPoints[i];
                const next = bufferedPoints[(i + 1) % bufferedPoints.length];
                
                smoothedPoints.push(current);
                
                // Add intermediate point for smoother curves
                smoothedPoints.push({
                    lat: (current.lat + next.lat) / 2,
                    lng: (current.lng + next.lng) / 2
                });
            }
            
            return smoothedPoints;
        }
        
        function normalize(vector) {
            const length = Math.sqrt(vector.lat * vector.lat + vector.lng * vector.lng);
            if (length === 0) return { lat: 0, lng: 0 };
            return { lat: vector.lat / length, lng: vector.lng / length };
        }
        
        function perpendicular(vector) {
            return { lat: -vector.lng, lng: vector.lat };
        }

        function addTourMarkers(coordinates, color) {
            // This function is replaced by addTourStopMarkers
            // Kept for compatibility
        }

        function updateLegend() {
            const legendContent = document.getElementById('legend-content');
            legendContent.innerHTML = '';
            
            tours.forEach(tour => {
                const legendItem = document.createElement('div');
                legendItem.className = 'legend-item';
                legendItem.innerHTML = `
                    <div class="legend-color" style="background-color: ${tour.color}"></div>
                    <div class="legend-label">${tour.name}</div>
                `;
                legendContent.appendChild(legendItem);
            });
        }

        function showTourCard(tour) {
            activeTourCard = tour;
            
            // Update tour card content
            document.getElementById('tour-title').textContent = tour.name;
            document.getElementById('tour-subtitle').textContent = tour.subtitle;
            document.getElementById('tour-description').textContent = tour.description;
            document.getElementById('tour-stops').textContent = tour.stops;
            document.getElementById('tour-duration').textContent = tour.duration;
            document.getElementById('tour-distance').textContent = tour.distance;
            
            // Update image (placeholder for now)
            const tourImage = document.getElementById('tour-image');
            if (tour.photoUrl) {
                tourImage.style.backgroundImage = `url(${tour.photoUrl})`;
                tourImage.style.backgroundSize = 'cover';
                tourImage.style.backgroundPosition = 'center';
                tourImage.textContent = '';
            } else {
                tourImage.style.backgroundImage = `linear-gradient(135deg, ${tour.color}88, ${tour.color}cc)`;
                tourImage.textContent = 'ðŸ“¸ Tour Photo';
            }
            
            // Show tour card
            document.getElementById('tour-card').classList.add('visible');
        }

        function closeTourCard() {
            document.getElementById('tour-card').classList.remove('visible');
            activeTourCard = null;
        }

        function previewTour() {
            if (!activeTourCard) return;
            
            // This could show a detailed route preview or photo gallery
            alert(`Preview functionality for ${activeTourCard.name} - coming soon!`);
        }

        function startTour() {
            if (!activeTourCard) return;
            
            // Send message to Draftbit app OR navigate to navigation map
            const tourData = {
                action: 'start_tour',
                tourId: activeTourCard.id,
                tourName: activeTourCard.name,
                addresses: activeTourCard.addresses
            };
            
            // Option 1: Send to parent app via PostMessage (if in webview)
            if (window.ReactNativeWebView) {
                window.ReactNativeWebView.postMessage(JSON.stringify(tourData));
            }
            
            // Option 2: Navigate to navigation map with parameters
            const navigationUrl = `./navigation.html?tour=${encodeURIComponent(JSON.stringify(tourData))}`;
            window.location.href = navigationUrl;
            
            // Option 3: Custom URL scheme (uncomment if using deep links)
            // window.location.href = `laapp://start-tour?id=${activeTourCard.id}`;
        }

        // Touch handling for mobile
        let startY = 0;
        document.getElementById('tour-card').addEventListener('touchstart', (e) => {
            startY = e.touches[0].clientY;
        });

        document.getElementById('tour-card').addEventListener('touchmove', (e) => {
            const currentY = e.touches[0].clientY;
            const diffY = startY - currentY;
            
            if (diffY < -100) { // Swipe down to close
                closeTourCard();
            }
        });
    </script>

    <script async defer
        src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDDdD8BAz34j_0zv-G3qJKTP5sKQn7PQ1w&callback=initMap">
    </script>
</body>
</html>
